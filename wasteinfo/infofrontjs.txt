ğŸ”¹ Function to get tasks
async function fetchTasks() {


Declares an async function (so you can use await inside).

This function will fetch all tasks from the server and display them in the page.

  const res = await fetch("/tasks");


fetch("/tasks") sends a GET request to your backend API (/tasks).

await means: pause until the server responds.

res will be the HTTP Response object.

  const tasks = await res.json();


Reads the response body as JSON.

Now tasks is a JavaScript array of objects (each task with id, title, etc.).

  const list = document.getElementById("taskList");
  list.innerHTML = "";


Finds the <ul> or <ol> element with id="taskList".

Clears its contents ("") before adding new tasks (so the list refreshes).

ğŸ”¹ Loop through tasks
  tasks.forEach(t => {


Loops through each task object (t) in the tasks array.

    const li = document.createElement("li");


Creates a new <li> element in the DOM (a list item).

    li.textContent = `${t.id}. ${t.title} | ${t.description} | Assigned: ${t.assigned_to || 'N/A'} | Status: ${t.status} | Deadline: ${t.deadline || 'N/A'}`;


Sets the text inside <li> with template literals.

${t.assigned_to || 'N/A'} means:

If assigned_to exists â†’ show it.

Otherwise â†’ show "N/A".

ğŸ”¹ Add "Done" button (if task not done yet)
    if (t.status !== 'done') {


Only show a "âœ” Done" button if the taskâ€™s status is not already "done".

      const doneBtn = document.createElement("button");
      doneBtn.textContent = "âœ” Done";


Create a <button> with label "âœ” Done".

      doneBtn.onclick = async () => {
        await fetch("/update", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id: t.id, status: 'done' })
        });
        fetchTasks();
      };


When button is clicked:

Send a POST request to /update with JSON:

{ "id": t.id, "status": "done" }


After updating, call fetchTasks() again to refresh the list.

      li.appendChild(doneBtn);
    }


Adds the button inside the <li>.

ğŸ”¹ Add "Delete" button
    const delBtn = document.createElement("button");
    delBtn.textContent = "âŒ Delete";


Create a button labeled "âŒ Delete".

    delBtn.onclick = async () => {
      await fetch("/delete", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: t.id })
      });
      fetchTasks();
    };


When clicked:

Send POST request to /delete with { "id": t.id }.

Refresh the task list by calling fetchTasks() again.

    li.appendChild(delBtn);


Add the delete button to the <li>.

    list.appendChild(li);
  });
}


Finally, add the whole <li> (with task text + buttons) to the task list in the DOM.

ğŸ”¹ Function to add new task
async function addTask() {


Declares another async function for adding tasks.

  const title = document.getElementById("title").value;
  const description = document.getElementById("description").value;
  const assigned_to = document.getElementById("assigned_to").value || null;
  const team_id = document.getElementById("team_id").value || null;
  const deadline = document.getElementById("deadline").value || null;


Reads values from <input> fields in your HTML form.

If no value entered, it sets to null.

  await fetch("/add", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ title, description, assigned_to, team_id, deadline })
  });


Sends a POST request to /add.

Includes task details in JSON format.

  fetchTasks();
}


Refresh the task list after adding a new task.

ğŸ”¹ Initial call
fetchTasks();


When page loads, it calls fetchTasks() so the user immediately sees tasks from the database.

âœ… So basically:

fetchTasks() = GET all tasks + show them.

addTask() = POST a new task.

Inside fetchTasks(), each <li> has buttons to update (done) or delete a task






====================================================================================



ğŸŸ¢ async and await in JavaScript

They are used for handling asynchronous code â€” code that doesnâ€™t finish immediately (like fetching data from a server, reading a file, or waiting for a timer).

ğŸ”¹ The problem before async/await

JavaScript normally runs synchronously (line by line).
But some tasks (like fetching from /tasks) take time.
If JS waited (blocked), the whole browser would freeze until the request finished âŒ.

So we use asynchronous operations â†’ JS continues running while waiting for the slow task to finish.



ğŸ”¹ async function

If you mark a function with async, it automatically returns a Promise.
Example:

async function greet() {
  return "Hello!";
}

greet().then(msg => console.log(msg)); // Output: Hello!


So async is like saying:
ğŸ‘‰ "This function will run asynchronously and return a Promise."





ğŸ”¹ await

The await keyword can only be used inside an async function.
It pauses the function execution until the Promise is done.

Example:

function delay() {
  return new Promise(resolve => {
    setTimeout(() => resolve("Done!"), 2000);
  });
}

async function test() {
  console.log("Start");
  const result = await delay(); // waits 2 seconds
  console.log(result); // "Done!"
  console.log("End");
}

test();


Output:

Start
(wait 2 seconds)
Done!
End


Without await, youâ€™d need messy .then() callbacks.


=================================================================================




ğŸ”¹ 1. Synchronous vs Asynchronous
ğŸŸ¢ Synchronous

Code runs line by line, one after the other.

JS waits for each line to finish before moving on.

Example:

console.log("A");
console.log("B");
console.log("C");


Output (always in order):

A
B
C

ğŸ”´ Asynchronous

Some tasks (like fetching from a server, reading a file, timers) take time.

Instead of blocking everything, JS says:
ğŸ‘‰ "Start this task, Iâ€™ll continue with other code, and when youâ€™re done, let me know."

Example:

console.log("A");

setTimeout(() => {
  console.log("B"); // runs after 2 seconds
}, 2000);

console.log("C");


Output:

A
C
B   (after 2 seconds)


â¡ï¸ Notice: JS didnâ€™t wait for B. It jumped to C immediately. Thatâ€™s asynchronous.







ğŸ”¹ 2. Promise

A Promise is an object in JS that represents a value that may be available now, later, or never.

Pending â†’ The task hasnâ€™t finished yet.

Resolved (Fulfilled) â†’ Task finished successfully.

Rejected â†’ Task failed.

Example:

let promise = new Promise((resolve, reject) => {
  let success = true;
  
  if (success) {
    resolve("Task completed!");
  } else {
    reject("Task failed!");
  }
});

promise.then(result => console.log(result))
       .catch(error => console.log(error));


Output:

Task completed!





âœ… Summary

Synchronous â†’ line by line, blocking.

Asynchronous â†’ non-blocking, lets JS continue while waiting.

Promise â†’ an object that represents a future result (success or failure).

resolve() â†’ marks a Promise as "done successfully" and gives back a value.

reject() â†’ marks a Promise as "failed" with an error.






ğŸ”¹ resolve(value)

Marks the Promise as fulfilled.

The value you pass goes to the .then(...) or await.

Example:

const p1 = new Promise(resolve => {
  resolve("Hello world");
});

p1.then(result => console.log(result));
// Output: Hello world


Here "Hello world" is the value of the resolved Promise.
But it could be anything:

resolve(42);              // number
resolve({ a: 1, b: 2 });  // object
resolve([1, 2, 3]);       // array
resolve(true);            // boolean
resolve();                // undefined

ğŸ”¹ reject(error)

Marks the Promise as failed.

The argument goes to the .catch(...).

Example:

const p2 = new Promise((resolve, reject) => {
  reject("Something went wrong!");
});

p2.catch(err => console.log(err));
// Output: Something went wrong!


Again, you can reject with anything:

reject("Error message"); 
reject(new Error("Custom error")); 
reject(404); 
reject({ code: 500, message: "Server down" });


âœ… Rule of thumb:

Use resolve(...) when things go right â†’ pass back the "success result".

Use reject(...) when things go wrong â†’ pass back an "error reason".

ğŸ‘‰ In real-world APIs:

resolve(data) â†’ returns JSON from the server.

reject(error) â†’ returns error message/HTTP code.






===================================================================================


ğŸŸ¢ What fetch() Does

In JavaScript (browser or Node with polyfills), fetch() is a built-in function used to make HTTP requests (GET, POST, PUT, DELETE, etc.) to a server.

ğŸ‘‰ Think of it as your browser saying:
â€œHey server, give me some dataâ€ or
â€œHey server, hereâ€™s some data I want to save.â€

ğŸ”¹ Basic Syntax
fetch(url, options?)


url â†’ where to send the request (like /tasks, or https://api.github.com/users).

options (optional) â†’ an object that configures the request (method, headers, body, etc.).

ğŸ”¹ Example 1: Simple GET request
fetch("/tasks")
  .then(res => res.json())   // parse response into JSON
  .then(data => console.log(data));


This asks the server at /tasks for data (like your task list).

ğŸ”¹ Example 2: POST request with body
fetch("/add", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    title: "Finish project",
    description: "Due tomorrow"
  })
});


Here:

method: "POST" â†’ tells server weâ€™re sending data.

headers â†’ extra info (like "Iâ€™m sending JSON").

body â†’ actual data (must be a string, so we use JSON.stringify).

ğŸŸ¢ Can we put anything inside fetch()?

Yes and no:

First parameter (url) â†’ must be a string (the URL or endpoint).
Example: "/tasks", "https://google.com".

Second parameter (options object) â†’ you can put many settings, but only valid ones recognized by fetch.
Some common ones:

method â†’ "GET", "POST", "PUT", "DELETE".

headers â†’ { "Content-Type": "application/json" }.

body â†’ request payload (string, often JSON).

mode â†’ "cors", "no-cors", "same-origin".

credentials â†’ "same-origin", "include", "omit".

Example:

fetch("/update", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ id: 5, status: "done" })
});


âš ï¸ But you canâ€™t put totally random stuff (like fetch("/tasks", 12345)), because fetch expects a specific format.

ğŸŸ¢ What fetch returns

ğŸ‘‰ A Promise that eventually gives you a Response object.

Example:

const res = await fetch("/tasks");
console.log(res.status); // HTTP status code (200, 404, etc.)
console.log(res.ok);     // true if success
console.log(await res.json()); // get body as JSON


âœ… In short:

fetch() makes HTTP requests to a server.

First argument: URL.

Second argument: options (method, headers, body, etc.).

Returns a Promise â†’ you can await it or use .then().



===================================================================


ğŸŸ¢ 1. What do options do in fetch()?

options is the second argument of fetch().
It tells the browser how you want to make the HTTP request.

ğŸ‘‰ Think of it like giving instructions to the waiter in a restaurant:

"GET" â†’ "Just bring me the menu."

"POST" â†’ "Hereâ€™s my order, add it to the system."

"DELETE" â†’ "Cancel my order."

Headers â†’ "By the way, Iâ€™m vegan, so no meat please."

Body â†’ "Hereâ€™s my actual order details."

Common options fields:
fetch("/add", {
  method: "POST",                        // HTTP method (default is GET)
  headers: { "Content-Type": "application/json" }, // extra info for server
  body: JSON.stringify({ title: "New Task" })      // request payload
});


method: "GET", "POST", "PUT", "DELETE", etc.

headers: extra information sent with the request (like content type, authorization token).

body: actual data you want to send (must be string if JSON, so we JSON.stringify).

mode: controls CORS (Cross-Origin stuff).

credentials: whether to include cookies/auth info.

âœ… Without options, fetch(url) defaults to a simple "GET" request.

ğŸŸ¢ 2. What does await do?

Remember fetch() returns a Promise.
That means it doesnâ€™t give you the data immediately â€” it says:
ğŸ‘‰ "Iâ€™ll give it to you later when itâ€™s ready."

await is like saying:
ğŸ‘‰ "Pause this function until the Promise finishes, then continue with the result."

Example without await (using .then)
fetch("/tasks")
  .then(res => res.json())
  .then(data => console.log(data));

Same example with await
async function getTasks() {
  const res = await fetch("/tasks");  // wait for response
  const data = await res.json();      // wait for JSON parsing
  console.log(data);
}


âœ… The big advantage:
await makes async code look like normal step-by-step code.

ğŸŸ¢ Analogy

Think of await like waiting at the counter until your food is ready, instead of juggling multiple receipts and callbacks.

const res = await fetch("/tasks");  


= â€œIâ€™ll stand here until the server hands me the response, then Iâ€™ll move on.â€

âœ… In short:

options â†’ tells fetch how to behave (method, headers, body, etc.).

await â†’ pauses inside an async function until the Promise (like fetch) is done, so you can work with the actual result.


====================================================


ğŸŸ¢ 1. Why not just use a normal function?

A normal function runs synchronously â†’ step by step.

But network requests (fetch) are asynchronous:

It takes time to travel across the internet ğŸŒ

If JS blocked (waited the old way), your entire page would freeze until the server responded.

So instead, JS uses Promises to represent the "eventual result."
That way, the browser can keep running other code while waiting.

Example with normal function (not possible):

function getTasks() {
  const res = fetch("/tasks");   // âŒ this doesn't return data, it returns a Promise
  const tasks = res.json();      // âŒ tasks isn't ready yet
  console.log(tasks);
}


ğŸ‘‰ This wonâ€™t work because fetch hasnâ€™t finished yet.

Thatâ€™s why we need either:

.then() style (callbacks), or

async/await style (looks like synchronous, but isnâ€™t blocking).







ğŸŸ¢ 1. Why not just use a normal function?

A normal function runs synchronously â†’ step by step.

But network requests (fetch) are asynchronous:

It takes time to travel across the internet ğŸŒ

If JS blocked (waited the old way), your entire page would freeze until the server responded.

So instead, JS uses Promises to represent the "eventual result."
That way, the browser can keep running other code while waiting.

Example with normal function (not possible):

function getTasks() {
  const res = fetch("/tasks");   // âŒ this doesn't return data, it returns a Promise
  const tasks = res.json();      // âŒ tasks isn't ready yet
  console.log(tasks);
}


ğŸ‘‰ This wonâ€™t work because fetch hasnâ€™t finished yet.

Thatâ€™s why we need either:

.then() style (callbacks), or

async/await style (looks like synchronous, but isnâ€™t blocking).

ğŸŸ¢ 2. What does res.json() do?

When you call fetch, it returns a Response object.
This contains info like:

{
  status: 200,
  ok: true,
  headers: { ... },
  body: ReadableStream   // raw stream of bytes from the server
}


But the body isnâ€™t immediately a usable object. Itâ€™s raw data.

ğŸ‘‰ res.json() is a method on the Response object that reads the body, parses it as JSON, and returns a Promise that resolves to a JavaScript object/array.

Example:

const res = await fetch("/tasks"); 
console.log(res.status);   // 200
console.log(res.ok);       // true

const tasks = await res.json();  // parses JSON
console.log(tasks); // now you get usable JS array/object


If server sent this JSON:

[
  { "id": 1, "title": "Finish homework" },
  { "id": 2, "title": "Buy milk" }
]


Then tasks in JS becomes:

[
  { id: 1, title: "Finish homework" },
  { id: 2, title: "Buy milk" }
]

ğŸŸ¢ 3. What does a Promise return look like?

Letâ€™s try it out:

const res = fetch("/tasks");
console.log(res);


Youâ€™ll see something like:

Promise { <pending> }


Why? Because the request is still in progress.
Later it becomes:

Promise { Response }


Where Response is:

Response {
  body: ReadableStream,
  bodyUsed: false,
  headers: Headers,
  ok: true,
  redirected: false,
  status: 200,
  statusText: "OK",
  type: "basic",
  url: "http://localhost:3000/tasks"
}


And then if you do:

const data = await res.json();
console.log(data);


You finally see the actual task data as a JS object/array.

âœ… In short:

Normal functions canâ€™t "pause" for network requests â†’ thatâ€™s why we use Promises + async/await.

res.json() converts the raw server response into usable JS objects.

A Promise looks like { <pending> } at first, then "resolves" with either success (value) or failure (error).


========================================================...


ğŸŸ¢ 1. What is res.json() really?

When you do:

const res = await fetch("/tasks");
const tasks = await res.json();


res is a Response object (not the actual data yet).

res.json() is a method on that Response object.

ğŸ‘‰ What it does:

Reads the raw HTTP response body (bytes/stream).

Parses it as JSON text.

Returns a Promise that resolves to a JavaScript object/array.

Example:

If the server sent this response:

HTTP/1.1 200 OK
Content-Type: application/json

[
  { "id": 1, "title": "Finish homework" },
  { "id": 2, "title": "Buy groceries" }
]


Then:

const res = await fetch("/tasks");
const tasks = await res.json();
console.log(tasks);


Youâ€™ll see:

[
  { id: 1, title: "Finish homework" },
  { id: 2, title: "Buy groceries" }
]


So res.json() = "Give me the response body as a JavaScript object, assuming itâ€™s JSON."

ğŸŸ¢ 2. When did we create /tasks?

Back in your server.js, you wrote:

app.get("/tasks", (req, res) => {
  const query = `
    SELECT t.id, t.title, t.description, t.status, u.username AS assigned_to, t.deadline
    FROM tasks t LEFT JOIN users u ON t.assigned_to = u.id
    ORDER BY t.created_at DESC
  `;
  db.query(query, (err, results) => {
    if (err) throw err;
    res.json(results);  // ğŸ”´ HERE is where JSON comes from
  });
});


ğŸ‘‰ This line:

app.get("/tasks", ...)


creates an API endpoint at /tasks.

Whenever someone (browser, frontend JS, Postman, etc.) calls GET /tasks, the server runs the SQL query, fetches tasks from the database, and sends them back as JSON.

ğŸ‘‰ This line:

res.json(results);


sends the array of tasks from MySQL to the client as JSON.

ğŸŸ¢ 3. Connecting it together

In your backend (server.js) you created the endpoint /tasks that responds with JSON.

In your frontend (fetchTasks) you call /tasks using fetch.

The browser gives you a Response object.

You call res.json() to parse it.

Now you finally have a usable JavaScript array of task objects.

âœ… So in short:

res.json() = parses serverâ€™s JSON response â†’ usable JS object.

/tasks was created in your backend with app.get("/tasks", ...).

Without that route, fetch("/tasks") would give a 404.



================================================================


ğŸŸ¢ 1. What is a Response object?

When you use fetch(), the browser (or Node) goes out to the server and asks:
ğŸ‘‰ â€œHey server, please give me data from /tasks.â€

The server replies with an HTTP response.

This response isnâ€™t just the data â€” it includes:

status code (200 OK, 404 Not Found, 500 Error, etc.)

headers (metadata, like content type)

body (the actual data, like JSON, HTML, plain text, etc.)

The browser wraps all that into a Response object for you.

Example:
const res = await fetch("/tasks");
console.log(res);


Youâ€™ll see something like:

Response {
  ok: true,
  status: 200,
  statusText: "OK",
  headers: Headers,
  url: "http://localhost:3000/tasks",
  body: ReadableStream
}


res.status â†’ 200 (means success).

res.ok â†’ true if status is in the 200â€“299 range.

res.headers â†’ extra info about the response.

res.body â†’ the raw response body (a stream of bytes).

âš ï¸ Notice: res.body isnâ€™t automatically a JS object â€” itâ€™s raw data.

Thatâ€™s where parsing comes in.

ğŸŸ¢ 2. What is parsing?

ğŸ‘‰ Parsing = converting raw data (text/bytes) into a structured format that your program can actually use.

Example with JSON:

The server sends this raw JSON string:

"[{\"id\":1,\"title\":\"Do homework\"},{\"id\":2,\"title\":\"Buy milk\"}]"


Looks messy, right? Thatâ€™s just text.

When you call:

const tasks = await res.json();


ğŸ‘‰ The browser parses that JSON string into a real JavaScript array:

[
  { id: 1, title: "Do homework" },
  { id: 2, title: "Buy milk" }
]


Now you can loop through it, display it, etc.

Other kinds of parsing:

res.text() â†’ parses response body as plain text.

res.json() â†’ parses response body as JSON â†’ JS object.

res.blob() â†’ parses as binary (files, images).

res.formData() â†’ parses as form fields.

ğŸŸ¢ 3. Analogy

Imagine you get a letter in the mail:

Envelope â†’ metadata (headers).

Stamp â†’ status (did it arrive or fail?).

Paper with text â†’ body (raw data).

If the letter says:

{"id": 1, "task": "Clean room"}


ğŸ‘‰ Thatâ€™s JSON text.

Parsing = you read that text and turn it into a mental model (a structured object you can actually work with).

âœ… Summary

A Response object = the whole reply from the server (status, headers, body).

The body is raw data â†’ needs parsing.

Parsing = converting raw text/bytes â†’ usable JS objects/arrays.

res.json() is one parser for JSON bodies.





